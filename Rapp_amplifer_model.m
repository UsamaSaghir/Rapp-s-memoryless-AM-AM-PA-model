clc;clear;

symbol_rate  = 40e6;    % Symbol rate
M = 16;                 % Modulation Order
alpha = 0.25;           % 25% excess bandwidth: Roll-off of root-raised cosine (RRC) pulse-shaping filter
osf = 8;                % Oversampling factor
Fs = osf*symbol_rate;   % Sampling rate
nSymb = 5000;           % Number of generated symbols
span = 16;              % Span of the RRC filter (in symbols)
nRRC = osf*span;        % RRC filter order

% Design RRC filter:
hRRC = sqrt(osf)*rcosdesign(alpha, span, osf);

% Generate signal % upsampling/interpolation:
symbol_stream = randi(M,1,nSymb)-1;             % Generating symbol indexes for QAM symbol
mod_tx = qammod(symbol_stream,M);               % Modulated QAM symbols
upsamp_mod_tx = upsample(mod_tx, osf);          % Upsampled QAM symbols
Tx_sig = conv(hRRC,upsamp_mod_tx);              % This is the generated TX signal

% Note: The generated signal contains the symbol block of osf*nSymb samples
% and impulse response tails of nRRC/2 samples on both sides. It is better
% to remove the tails after RRC filtering in RX.
%%
% To plot the AM-AM conversion of Rapp PA model, we will use a test signal.

test_sig = linspace(0, 10, 1000);                   % Creates a test signal with amplitude 0 to 10 with 10,000 elements
out_test = Rapp(test_sig);                          % Output refernce signal generated by the PA model
diff = mag2db(test_sig) - mag2db(out_test);         % Difference in dB b/w output & input
index_1dB = find(diff >= 1, 1);
com_1dB = mag2db(test_sig(index_1dB));
fprintf('The 1dB compression point reffered to the input is : %f dB\n', com_1dB);

figure()
p1 = plot(mag2db(test_sig), mag2db(out_test), 'LineWidth', 2, 'DisplayName', '|y(t)|'); hold on;
p2 = plot(mag2db(test_sig), mag2db(test_sig), '--', 'DisplayName', '|x(t)|'); hold on;
p3 = plot(com_1dB, com_1dB,  'k*', 'DisplayName', 'P1dB');hold on;
title('Rapp PA Model - AM-AM Conversion in dB');
xlabel('Input Signal Amplitude |x(t)| (dB)');ylabel('Output Signal Amplitude |y(t)| (dB)');
grid on; axis([ -40 10, -40 10]);
yline(mag2db(out_test(index_1dB)), 'm:', 'LineWidth', 2); hold on;
yline(mag2db(test_sig(index_1dB)), 'm:', 'LineWidth', 2); hold on;
legend([p1, p2, p3],'Location', 'northwest');

%% Rescaling the origina QAM symbols to proper backoffs

QAM_0dB = Rapp(scale_input(Tx_sig, 0, com_1dB));
QAM_5dB = Rapp(scale_input(Tx_sig, 5, com_1dB));
QAM_10dB = Rapp(scale_input(Tx_sig, 10, com_1dB));

[Pxx_input, f_input] = pspectrum(Tx_sig, Fs);
[Pxx_output, f_output] = pspectrum(QAM_0dB, Fs, 'TwoSided', true);
[Px2_output, f_out2] = pspectrum(QAM_5dB, Fs, 'TwoSided', true);
[Px3_output, f_out3] = pspectrum(QAM_10dB, Fs, 'TwoSided', true);

figure()    
plot(f_input/(10^6), 10*log10(Pxx_input), 'LineWidth',1.25); hold on;
plot(f_output/(10^6), 10*log10(Pxx_output)); hold On;
plot(f_out2/(10^6), 10*log10(Px2_output)); hold on;
plot(f_out3/(10^6), 10*log10(Px3_output)); hold on;
xlabel('Frequency (Hz)');
ylabel('Power(dB)');
title('Power Spectrum of Input and Output Signals');grid on;
legend('x(t)', 'y(t) with back-off 0dB', 'y(t) with back-off 5dB'...
  ,'y(t) with back-off 10dB');

ALCR_0dB = ALCR_cal(QAM_0dB, Fs);
fprintf(['The ALCR of the scaled amplified QAM signal with backoff 0dB' ...
    ' is : %f \n'], ALCR_0dB);
ALCR_5dB = ALCR_cal(QAM_5dB,  Fs);
fprintf(['The ALCR of the scaled amplified QAM signal with backoff 5dB is' ...
    ' : %f \n'], ALCR_5dB);
ALCR_10dB = ALCR_cal(QAM_10dB, Fs);
fprintf(['The ALCR of the scaled amplified QAM signal with backoff 10dB is' ...
    ' : %f \n'], ALCR_10dB);

%% Function definitions

function [ALCR] = ALCR_cal(input, Fs)
    channel_width = 40e6;      % Channel width (40 MHz)
    spacing = 50e6;            % Spacing between channels (50 MHz)  
    in_ch_start = 100e3;
    in_ch_stop = 40.1e6;
    adj_ch_start = ((in_ch_start + channel_width)/2)+(spacing/2);
    adj_ch_stop = adj_ch_start + channel_width;
    Y = abs(fft(input)); % DFT of y_PA (the PA output signal) 
    P_in_ch = sum(Y(ceil(in_ch_start/Fs*length(Y)):round(in_ch_stop/Fs*length(Y))).^2);
    P_adj_ch = sum(Y(round(adj_ch_start/Fs*length(Y)):round(adj_ch_stop/Fs*length(Y))).^2);
    ALCR = 10*log10(P_in_ch/P_adj_ch);
end

function [output] = Rapp(input)
    x_sat = 1;
    p = 2.5;
    output = (abs(input)./ ((1+((abs(input)./x_sat).^(2*p))).^(1/(2*p)))).*(exp(angle(input)));
end

function [scaled] = scale_input(input, backoff, P1dB)
    avg_in = mean((abs(input)).^2);
    scaled = sqrt((10^((P1dB-backoff)/10))/avg_in);
    scaled = scaled.*input;
end
